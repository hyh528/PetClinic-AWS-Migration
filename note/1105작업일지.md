# 2025년 11월 05일 작업일지

## 1. API Gateway 구조 변경 및 오류 해결 과정

### 1.1. 목표: 복잡한 API 경로 구조 구현

정상 동작하는 다른 프로젝트의 API Gateway 구조(`what.png` 예시)와 동일하게, 우리 프로젝트의 API Gateway도 아래와 같은 복합적인 경로 구조를 갖도록 수정하는 것을 목표로 삼았습니다.

- 루트(`/`) 경로 바로 아래에 '전역 프록시'(`/{proxy+}`)가 존재.
- 동시에 `/admin`과 같은 특정 경로 아래에도 별도의 프록시(`/{proxy+}`)가 존재.

### 1.2. 1차 시도 및 `BadRequestException` 오류 발생

`terraform/modules/api-gateway/main.tf` 파일에 루트 `/{proxy+}` 리소스를 추가하고 배포를 시도했으나, 아래와 같은 오류가 발생했습니다.

```
Error: creating API Gateway Resource: ... BadRequestException: A sibling ({proxy+}) of this resource already has a variable path part -- only one is allowed
```

초기에는 이 오류를 "API Gateway는 이런 복잡한 구조를 허용하지 않는다"라고 해석했습니다.

### 1.3. 원인 분석: 리소스 생성 순서 문제

정상 동작하는 프로젝트의 Terraform 코드(`note/png/main.tf`)를 분석한 결과, 진짜 원인은 **리소스 생성 순서**에 있다는 것을 발견했습니다.

- **성공하는 코드의 비밀**: 모든 구체적인 경로(`- /admin`, `/api`, `/admin/{proxy+}` 등)를 먼저 정의하고, 그 다음에 **가장 마지막 순서로** '그 외 모든 것을 잡는' 전역 프록시(`/{proxy+}`)를 정의했습니다.
- **실패 원인**: 우리 코드에서는 이 순서가 보장되지 않아, Terraform이 전역 프록시를 먼저 만들려고 시도하다가 다른 경로와의 모호성 문제로 API 생성에 실패한 것입니다.

### 1.4. 최종 해결 방안

Terraform이 리소스를 올바른 순서로 생성하도록 유도하기 위해, `main.tf` 파일을 아래와 같이 수정했습니다.

1.  **전역 프록시 리소스 추가**: 다른 모든 경로 리소스가 정의된 후, 파일의 뒷부분(CORS 섹션 이전)에 전역 프록시 관련 리소스 3개를 추가했습니다.

    ```terraform
    # --------------------------------------
    # 3) 전역 프록시 (Global Proxy)
    # 다른 모든 특정 경로가 정의된 후 마지막에 배치하여 생성 순서를 유도합니다.
    # --------------------------------------
    resource "aws_api_gateway_resource" "root_proxy" {
      rest_api_id = aws_api_gateway_rest_api.this.id
      parent_id   = aws_api_gateway_rest_api.this.root_resource_id
      path_part   = "{proxy+}"
    }

    resource "aws_api_gateway_method" "root_proxy_any" {
      # ...
    }

    resource "aws_api_gateway_integration" "root_proxy_alb" {
      # ...
    }
    ```

2.  **배포 트리거 수정**: `aws_api_gateway_deployment` 리소스의 `triggers` 블록에 새로 추가한 전역 프록시 리소스들의 ID를 포함시켜, 변경 시 자동으로 재배포되도록 수정했습니다.

    ```terraform
      triggers = {
        redeployment = sha1(jsonencode([
          # ... (기존 내용) ...
          # 전역 프록시
          aws_api_gateway_resource.root_proxy.id,
          aws_api_gateway_method.root_proxy_any.id,
          aws_api_gateway_integration.root_proxy_alb.id,
          # ... (이후 내용) ...
        ]))
      }
    ```

## 2. 주요 Q&A 및 개념 정리

### 2.1. `OPTIONS` 메소드의 역할

- **목적**: 웹 브라우저의 CORS(Cross-Origin Resource Sharing) 정책을 처리하기 위해 사용됩니다.
- **동작**: 다른 도메인의 웹사이트에서 우리 API로 `POST`, `PUT` 같은 복잡한 요청을 보낼 때, 브라우저는 실제 요청 전에 `OPTIONS` 메소드로 "요청을 보내도 되는지"를 먼저 물어봅니다(사전 요청, pre-flight).
- **결론**: `OPTIONS` 메소드 설정이 없으면, API Gateway가 이 사전 요청에 응답하지 못해 브라우저가 실제 요청을 차단하고 CORS 오류를 발생시킵니다. 따라서 웹사이트에서 API를 호출하려면 `OPTIONS` 설정이 필수적입니다.

### 2.2. ECS 태스크 종료 코드 143의 의미

- **상황**: 새로운 버전의 태스크를 배포했더니, 기존에 실행되던 태스크가 종료 코드 143과 함께 중지됨.
- **의미**: **정상적인 종료**입니다. 종료 코드 143은 외부로부터 `SIGTERM` 종료 신호를 받아 애플리케이션이 안전하게 종료되었음을 의미합니다.
- **과정**: ECS의 롤링 업데이트 배포 시, 새로운 태스크가 정상 상태가 되면 ECS는 이전 태스크에게 종료 신호를 보냅니다. 이 신호를 받은 이전 태스크가 정상적으로 종료되면서 남기는 코드가 143입니다.

## 3. Git Push 오류 해결

- **문제**: `git push` 시 `! [rejected] (fetch first)` 오류 발생.
- **원인**: 원격 저장소에 로컬에는 없는 새로운 변경사항이 있어, 기록 충돌을 막기 위해 Git이 푸시를 거부함.
- **해결**: `git pull <리모트_이름> <브랜치_이름>` 명령어로 원격 저장소의 최신 내용을 먼저 로컬로 가져와 병합(merge)한 후, 다시 `git push`를 실행합니다.
